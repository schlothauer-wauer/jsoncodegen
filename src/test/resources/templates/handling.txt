<%
    /** For enabling/disabling debug output */
    def verbose = Boolean.parseBoolean(extraParam.verbose)
    /** The name of the Java class, which is being masked. */
    def targetType = upperCamelCase.call(currentType.name)
    /** This stack holds the property (names) visited while traversing the object hierarchy.*/
    List<?> propStack = []
    /** Indicates that this property is an array. This sack is build while traversing the object hierarchy. */
    List<Boolean> propIsArrayStack = []
    /**
     * Indicates that this property or any of its parents was an array and that we therefore have to process an collection.
     * This sack is build while traversing the object hierarchy.
     */
    List<Boolean> propIsCollectionStack = []
    /**
     * Defines overwrites for maskKeys (mapping of property name to associated mask key).
     * This may be necessary for e.g. Joined types, where on property holds the Id of the joined object, and another
     * property holds the joined object itself (property objectBaseId vs. property objectBase).
     */
    Map<String, String> maskKeyOverwrites = [:]
    /** For caching the lines generated by the (recursive) closure calls of the model loops! */
    List<String> allLines = []
    /** Indicates whether the current type is a joined type */
    def joined = targetType.endsWith('Joined')

    if (verbose) println "type=${currentType.name} javaType=${targetType} joined=$joined"

    /** Forward declaration of closure, which calls itself! */
    def tuneType

    /**
     * <b>THIS METHOD ALTERS THE MODEL!!!</b>
     * This method tunes the properties of a (complex or reference) type and calls itself recursively if the type
     * itself holds properties of other (complex or reference) types.
     * Checks for properties with the tag <i>prepLookup</i> and
     * <ul>
     * <li>joined==true: removes the property completely</li>
     * <li>joined==false: removes the suffix Id</li>
     * @param type The type to process.
     */
    tuneType = { type ->
        Closure<Void> action
        if (joined) {
            action = { prop ->
                println "// ATTENTION: Removing lookup property ${prop.name}"
                type.properties.remove(prop)
            }
        } else {
            action = { prop ->
                def orig = prop.name
                def shorten = prop.name.take(prop.name.length() - 2)
                println "// ATTENTION: Renaming lookup property from $orig to $shorten"
                prop.setName(shorten)
            }
        }
        Collection<?> lookupProps = type.properties.findAll { prop -> prop.hasTag('prepLookup') && prop.name.endsWith('Id') }
        type.properties.findAll { prop -> prop.implicitRefIsRefType()   && !prop.isSelfReference() } each { prop -> tuneType.call(prop.implicitRef.type) }
        type.properties.findAll { prop -> prop.isRefTypeOrComplexType() && !prop.isSelfReference() } each { prop -> tuneType.call(prop.type.type) }
        lookupProps.each(action)
    }

    /**
     * Prepares the stacks for running the next loop over the model
     */
    def prepareStacks = {
        propStack.clear()
        propIsArrayStack.clear()
        // avoid extra case for handling empty stack!
        propIsCollectionStack = [false]
    }

    /**
     * Adds new elements to the stacks
     * @param property The property, which is to be visited
     */
    def putStacks = { property ->
        propStack.add(property)
        propIsArrayStack.add(property.type.isArray)
        // If either already collection of if this property is an collection.
        propIsCollectionStack.add(propIsCollectionStack.last() || property.type.isArray)
    }

    /**
     * Pops the latest elements from the stacks
     */
    def popStacks = {
        propStack.pop()
        propIsArrayStack.pop()
        propIsCollectionStack.pop()
    }

    /**
     * Processes a ref or complex property.
     * Take the property's type, looks through it properties and returns the one of type UUID.
     * That should usually be the entryId or guid!
     */
    def findIdProperty = { property ->
        def type = property.type.type
        List candidates = type.properties.findAll { prop -> prop.type.name() == 'UUID'} // (${type.type.name()})
        if (candidates.isEmpty() && type.name == 'ListEntry') {
            // ListEntry usually have a StringType property refId (wanted) and text (to be avoided)
            candidates.addAll( type.properties.findAll { prop -> prop.type.name() == 'STRING' && prop.name == 'refId'} )
        }
        /*
        assert candidates.size() == 1 : "property=${property.name} type=${type.name} props=${type.properties.collect{ it.name }.join(', ')}"
        assert candidates[0].name == 'guid' || candidates[0].name == 'entryId' || candidates[0].name == 'refId'  : "property=${property.name} type=${type.name} props=${type.properties.collect{ it.name }.join(', ')}"
        */
        return candidates.isEmpty() ? null : candidates[0].name
    }

    /** Creates a key from current state of propStack, e.g. gis.area */
    Closure<String> currentKey = {
        return propStack.collect { prop -> prop.name}.join('.')
    }

    /** Forward declaration of closure, which calls itself! */
    def evalDeepNestedListKeys

    /**
     * Closure which actually looks for the array of ref or complex properties, for which a method removeXXXById(pojo, targetId)
     * needs to be created. This closure calls itself recursively!
     * @param type The type, which is to be processed
     * @param keys The list of keys, which is to be extended while traversing the model.
     */
    evalDeepNestedListKeys = { type, List<String> keys ->
        // find all ref & complex properties, which are hold in arrays! These are the candidates for the methods removeXXXById(pojo, targetId)
        type.properties.findAll{ prop -> prop.isRefTypeOrComplexType() && prop.type.isArray }.each { prop ->
            putStacks.call(prop)
            def key = currentKey.call()
            if (findIdProperty.call(prop)) {
                keys.add(key)
            } else {
                println "ATTENTION: Skip creating removeXXX(pojo, UUID) as property is missing proper ID: type=${currentType.name} key=${key}"
            }
            popStacks.call()
        }
        // recurse into all ref & complex properties, which are not hold in arrays!
        type.properties.findAll{ prop -> prop.isRefTypeOrComplexType() && !prop.type.isArray }.each { prop ->
            putStacks.call(prop)
            evalDeepNestedListKeys.call(prop.type.type, keys)
            popStacks.call()
        }
    }

    /**
     * Closure, which kicks off the search for the keys, which are candidates for the method removeXXXById(pojo, targetId)
     * -> find array of ref or complex properties
     * @param type The type, which is to be processed
     */
    def evalDeepNestedListKeysForType = { type ->
        // find keys for method removeXXXById(pojo, targetId) -> find array of ref or complex properties
        List<String> keys = []
        prepareStacks.call()
        evalDeepNestedListKeys.call(type, keys)
        return keys
    }

    /** Forward declaration of closure, which calls itself! */
    def evalOtherHandlingKeysForArrays

    /**
     * Closure which actually looks for the array of ref or complex properties, where another Handling class needs to be called.
     * (-> find array of ref or complex properties contained by array of ref or complex type - ignore children unless they lead to another relevant array)
     * This closure calls itself recursively!
     * @param type The type, which is to be processed
     * @param keys The list of keys, which is to be extended while traversing the model.
     * @param currDepth The number of array properties, one passed  when navigating to the current type
     */
    evalOtherHandlingKeysForArrays = { type, List<String> keys, int currDepth ->
        // find all ref & complex properties, which are hold in arrays! These are the candidates for the methods removeXXXById(pojo, UUID)
        type.properties.findAll{ prop -> prop.isRefTypeOrComplexType() && prop.type.isArray }.each { prop ->
            putStacks.call(prop)
            def key = currentKey.call()
            if (currDepth > 0) {
                if (findIdProperty.call(prop)) {
                    println "Call other handling class for deep nested array property: type=${currentType.name} key=${key}"
                    keys.add(key)
                } else {
                    println "ATTENTION: Skip calling other Handling classes as array property is missing proper ID: type=${currentType.name} key=${key}"
                }
            }
            popStacks.call()
        }
        // recurse into all ref & complex properties, array or not!
        type.properties.findAll{ prop -> prop.isRefTypeOrComplexType() }.each { prop ->
            if (prop.type.isArray) {
                currDepth++
            }
            putStacks.call(prop)
            evalOtherHandlingKeysForArrays.call(prop.type.type, keys, currDepth)
            if (prop.type.isArray) {
                currDepth--
            }
            popStacks.call()
        }
    }

    /**
     * Closure, which kicks off the search for the keys, where another Handling class needs to be called
     * -> find array of ref or complex properties contained by array of ref or complex type - ignore children unless they lead to another relevant array
     * @param type The type, which is to be processed
     */
    def evalOtherHandlingKeysForArraysForType = { type ->
        List<String> keys = []
        prepareStacks.call()
        evalOtherHandlingKeysForArrays.call(type, keys, 0)
        return keys
    }

    /** Forward declaration of closure, which calls itself! */
    def evalOtherHandlingKeys

    /**
     * Closure which actually looks for the array of ref or complex properties, where another Handling class needs to be called.
     * (-> find array of ref or complex properties contained by array of ref or complex type, and their ref of complex children)
     * This closure calls itself recursively!
     * @param type The type, which is to be processed
     * @param keys The list of keys, which is to be extended while traversing the model.
     * @param currDepth The number of array properties, one passed  when navigating to the current type
     */
    evalOtherHandlingKeys = { type, List<String> keys, int currDepth ->
        // find all ref & complex properties, which are hold in arrays! These are the candidates for the methods removeXXXById(pojo, UUID)
        type.properties.findAll{ prop -> prop.isRefTypeOrComplexType() }.each { prop ->
            putStacks.call(prop)
            def key = currentKey.call()
            def isArray = prop.type.isArray
            if (isArray && !findIdProperty.call(prop) ) {
                println "ATTENTION: Skip calling other Handling classes as array property is missing proper ID: type=${currentType.name} key=${key}"
                return
            }
            if (isArray) {
                currDepth++
            }
            if (currDepth > 1) {
                println "Call other handling class for deep nested array property: type=${currentType.name} key=${key}"
                keys.add(key)
            }
            // recurse into all ref & complex properties, array or not!
            evalOtherHandlingKeys.call(prop.type.type, keys, currDepth)
            if (prop.type.isArray) {
                currDepth--
            }
            popStacks.call()
        }
    }

    /**
     * Closure, which kicks off the search for the keys, where another Handling class needs to be called
     * -> find array of ref or complex properties contained by array of ref or complex type, and their ref of complex children
     * @param type The type, which is to be processed
     */
    def evalOtherHandlingKeysForType = { type ->
        List<String> keys = []
        prepareStacks.call()
        evalOtherHandlingKeys.call(type, keys, 0)
        return keys
    }

    /**
     * Take a key / chain of property names, and builds a matching property stack. e.g location.streets
     */
    def propStackFromKey = { String key ->
        List localPropStack = []
        def curType = currentType
        def curProp
        for (String propName : key.split('\\.')) {
            curProp = curType.properties.find { it.name == propName }
            assert curProp && curProp.isRefTypeOrComplexType() : "propChain=${propChain} propName=${propName}"
            localPropStack.add(curProp)
            curType = curProp.type.type
        }
        return localPropStack
    }

    /**
     * Splits the property stack into sub-stacks.
     * Each sub-stack starts and ends with an array property.
     * Exceptions: the first partition may not start with an array property, the last may not end with an array property.
     * Inner array properties are referenced twice: As the last element of sub-stack n and first element of sub-stack n+1
     */
    Closure<List<List<?>>> partitionArrayPros = { List<?> fullPropStack ->
        final List allList = []
        final List currList = []
        final Iterator <?> iter = fullPropStack.iterator()
        while (iter.hasNext()) {
            final def currProp = iter.next()
            currList.add(currProp)
            if (currProp.type.isArray) {
                allList.add(currList.clone())
                currList.clear()
                currList.add(currProp)
            }
        }
        if (currList.size() > 1) {
            allList.add(currList)
        }
        return allList
    }

    // Forward declaration of closure, which calls itself!
    def evalDeepNestedListChildKeys

    /**
     * Closure which actually looks for the single ref or complex child of array of ref or complex properties, for which
     * a method setXXXById(pojo, targetId, value) needs to be created. This closure calls itself recursively!
     * @param type The type, which is to be processed
     * @param key Defines the array of ref or complex properties, where single ref or complex child properties are to be found.
     * @param listKey2childKey The mapping of array key to child key,  which is to be extended while traversing the model.
     */
    evalDeepNestedListChildKeys = { type, String key, Map<String, String> listKey2childKey  ->
        type.properties.findAll{ prop -> prop.isRefTypeOrComplexType() && !prop.type.isArray }.each { prop ->
            putStacks.call(prop)
            def childKey = currentKey.call()
            listKey2childKey.put(key, childKey)
            // recurse into all ref & complex properties, which are not hold in arrays!
            evalDeepNestedListChildKeys.call(prop.type.type, key, listKey2childKey)
            popStacks.call()
        }
    }

    /**
     * Closure which kicks off the search for the keys, which are candidates for the method setXXXById(pojo, targetId, value)
     * -> find single ref or complex children of array of ref or complex properties
     */
    def evalDeepNestedListChildKeysForType = { type, List<String> keys ->
        Map<String, String> listKey2childKey = [:]
        for (String key : keys) {
            prepareStacks.call()
            // use key to restore prop stack of array property
            propStackFromKey.call(key).each { prop -> putStacks.call(prop) }
            // start recursive search for single ref or complex child
            assert propStack.last().isRefTypeOrComplexType() && propStack.last().type.isArray : key
            evalDeepNestedListChildKeys.call(propStack.last().type.type, key, listKey2childKey)
        }
        return listKey2childKey
    }

    /**
     * Prints the method boolean addXXX(pojo, additional) associated with one key,
     * where the array property is a child of the main type
     */
    Closure<String> printAddForKeyShallow = { String key ->
        if (verbose) println "// printAddForKeyShallow for key $key"
        List<?> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = upperCamelCase.call(currentType.name)
        def upperLast = upperCamelCase.call(localPropStack.last().name)
        def ret = """
    /**
     * Tries to add a ${typeNameInner} object to a ${typeName}.
     * @param pojo the parent object to extend
     * @param additional The ${typeNameInner} object to add to the ${typeName}
     * @return <i>True</i>, if the ${typeNameInner} object could be added to the ${typeName},
     *         <i>false</i> otherwise.
     */
    public static boolean add${keyUpper}(final ${typeName} pojo, final ${typeNameInner} additional) {
        if (check${keyUpper}Exists(pojo)) {
            get${keyUpper}(pojo).add(additional);
            return true;
        }
        List<${typeNameInner}> list = new ArrayList<>();
        list.add(additional);
        pojo.set${upperLast}(list);
        return true;
    }"""
        return ret
    }

    /**
     * Prints the method boolean addXXX(pojo, additional) associated with one key
     * of a deep nested array property.
     */
    Closure<String> printAddForKeyDeep = { String key ->
        if (verbose) println "// printAddForKeyDeep for key $key"
        List<?> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = upperCamelCase.call(currentType.name)
        List<?> parentStack = localPropStack.clone()
        parentStack.pop()
        def keyUpperParent = parentStack.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        def upperSecondLast = upperCamelCase.call(parentStack.last().name)
        def upperLast = upperCamelCase.call(localPropStack.last().name)
        def ret = """
    /**
     * Tries to add a ${typeNameInner} object to a ${typeName}.
     * @param pojo the parent object to extend
     * @param additional The ${typeNameInner} object to add to the ${typeName}
     * @return <i>True</i>, if the ${typeNameInner} object could be added to the ${typeName},
     *         <i>false</i> otherwise.
     */
    public static boolean add${keyUpper}(final ${typeName} pojo, final ${typeNameInner} additional) {
        if (check${keyUpper}Exists(pojo)) {
            get${keyUpper}(pojo).add(additional);
            return true;
        }if (!check${keyUpperParent}Exists(pojo)) {
            return false;
        }
        List<${typeNameInner}> list = new ArrayList<>();
        list.add(additional);
        pojo.get${upperSecondLast}().set${upperLast}(list);
        return true;
    }"""
        return ret
    }

    /**
     * Prints the method boolean addXXX(pojo, additional) associated with one key.
     * Delegates to either to printAddForKeyShallow or to printAddForKeyDeep
     */
    Closure<String> printAddForKey = { String key ->
        int depth = key.split('\\.').size()
        if (depth == 1) {
            return printAddForKeyShallow.call(key)
        }
        return printAddForKeyDeep.call(key)
    }

    /**
     * Prints the method void addXXX(pojo, additional) throws MissingXXXException associated with one key.
     */
    Closure<String> printAddForKeyThrows = { String key ->
        /*
            public static void addObjectBaseTags(final JunctionJoined pojo, final ListEntry additional)
                    throws MissingParentException, MissingTargetException {
                ensureObjectBaseTagsExists(pojo, false);
                getObjectBaseTags(pojo).add(additional);
            }
         */
        if (verbose) println "// printAddForKeyThrows for key $key"
        List<?> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = upperCamelCase.call(currentType.name)
        def ret = """
    /**
     * Adds a ${typeNameInner} object to a ${typeName}.
     * @param pojo the parent object to extend
     * @param additional The ${typeNameInner} object to add to the ${typeName}
     * @throws MissingTargetException if the attribute holding the ${typeNameInner} objects is null
     * @throws MissingParentException if any parent of the attribute holding the ${typeNameInner} objects is missing.
     */
    public static void add${keyUpper}(final ${typeName} pojo, final ${typeNameInner} additional)
            throws MissingParentException, MissingTargetException {
        ensure${keyUpper}Exists(pojo, false);
        get${keyUpper}(pojo).add(additional);
    }"""
        return ret
    }

    /**
     * Prints the method void getXXX(pojo, UUID, replacement) throws MissingXXXException associated with one key
     * of a nested array property.
     */
    Closure<String> printGetForKeyThrows = { String key ->
        /*
            public static AddressPerson getAddressPersonsById(final JunctionContact pojo, final UUID targetId)
                    throws MissingParentException, MissingTargetException {
                final ListIterator<AddressPerson> iter = getAddressPersonsThrows(pojo).listIterator();
                while (iter.hasNext()) {
                    if (iter.next().getAddressId().equals(targetId)) {
                        return iter.previous();
                    }
                }
                throw new MissingTargetException("address.persons", targetId);
            }
         */
        List<?>  localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = upperCamelCase.call(currentType.name)
        // usually one of entryId, guid or refId!
        def idProp = upperCamelCase.call(findIdProperty.call(localPropStack.last()))
        def ret = """
    /**
     * Returns a specific ${typeNameInner} object from a ${typeName}.
     * @param pojo The ${typeName} object to process
     * @param targetId The ID of the ${typeNameInner}, which is to be returned.
     * @throws MissingTargetException if no ${typeNameInner} of that id was found and subsequently returned,
     * @throws MissingParentException if the attribute holding the ${typeNameInner} objects or any of its parent objects is
     *             missing.
     */
    public static ${typeNameInner} get${keyUpper}ById(final ${typeName} pojo, final UUID targetId)
            throws MissingParentException, MissingTargetException {
        final ListIterator<${typeNameInner}> iter = get${keyUpper}Throws(pojo).listIterator();
        while (iter.hasNext()) {
            if (iter.next().get${idProp}().equals(targetId)) {
                return iter.previous();
            }
        }
        throw new MissingTargetException("${key}", targetId);
    }"""
        return ret
    }

    /**
     * Prints the method replaceXXX(pojo, UUID, replacement) associated with one key
     * of a nested array property.
     */
    Closure<String> printReplaceForKey = { String key ->
        List<?> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = upperCamelCase.call(currentType.name)
        // usually one of entryId, guid or refId!
        def idProp = upperCamelCase.call(findIdProperty.call(localPropStack.last()))
        def ret = """
    /**
     * Tries to replace a specific ${typeNameInner} object of a ${typeName}.
     * @param pojo The ${typeName} object to process
     * @param targetId The ID of the ${typeNameInner}, which is to be replaced.
     * @param replacement The ${typeNameInner} object to assign to the ${typeName}
     * @return <i>True</i>, if a ${typeNameInner} of that id was found and subsequently replaced,
     *         <i>false</i> if no object with that id could be found and therefore replaced.
     */
    public static boolean replace${keyUpper}ById(final ${typeName} pojo, final UUID targetId, final ${typeNameInner} replacement) {
        final ListIterator<${typeNameInner}> iter = get${keyUpper}(pojo).listIterator();
        while (iter.hasNext()) {
            if (iter.next().get${idProp}().equals(targetId)) {
                iter.set(replacement);
                return true;
            }
        }
        return false;
    }"""
        return ret
    }

    /**
     * Prints the method void replaceXXXById(pojo, targetId, replacement) throws MissingXXXException associated with one key
     * of a nested array property.
     */
    Closure<String> printReplaceForKeyThrows = { String key ->
        /*
            public static void replaceObjectBaseTagsById(final JunctionJoined pojo, final UUID targetId,
                    final ListEntry replacement) throws MissingParentException, MissingTargetException {
                final ListIterator<ListEntry> iter = getObjectBaseTagsThrows(pojo).listIterator();
                while (iter.hasNext()) {
                    if (iter.next().getRefId().equals(targetId)) {
                        iter.set(replacement);
                        return;
                    }
                }
                throw new MissingTargetException("objectBase.tags", targetId);
            }
         */
        List<?> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = upperCamelCase.call(currentType.name)
        // usually one of entryId, guid or refId!
        def idProp = upperCamelCase.call(findIdProperty.call(localPropStack.last()))
        def ret = """
    /**
     * Replaces a specific ${typeNameInner} object of a ${typeName}.
     * @param pojo The ${typeName} object to process
     * @param targetId The ID of the ${typeNameInner}, which is to be replaced.
     * @param replacement The ${typeNameInner} object to assign to the ${typeName}
     * @throws MissingTargetException if no ${typeNameInner} of that id was found and subsequently replaced,
     * @throws MissingParentException if the attribute holding the ${typeNameInner} objects or any of its parent objects is
     *             missing.
     */
    public static void replace${keyUpper}ById(final ${typeName} pojo, final UUID targetId,
            final ${typeNameInner} replacement) throws MissingParentException, MissingTargetException {
        final ListIterator<${typeNameInner}> iter = get${keyUpper}Throws(pojo).listIterator();
        while (iter.hasNext()) {
            if (iter.next().get${idProp}().equals(targetId)) {
                iter.set(replacement);
                return;
            }
        }
        throw new MissingTargetException("${key}", targetId);
    }"""
        return ret
    }

    /**
     * Prints the method void setXXXById(pojo, targetId, value) throws MissingXXXException associated for a the single ref
     * or complex child of an arrays of ref or complex properties
     * @param keyArray the key associated with an array of ref or complex property
     * @param keyChild the key associated with the the single ref or complex child of the array property.
     */
    Closure<String> printSetForKeyThrows = { String keyArray, String keyChild  ->
        /*
            public static void setAddressPersonsContactById(final JunctionContact pojo, final UUID targetId,
                    final ContactData value) throws MissingParentException, MissingTargetException {
                final ListIterator<AddressPerson> iter = getAddressPersonsThrows(pojo).listIterator();
                while (iter.hasNext()) {
                    iter.previous().setContact(value);
                    // TODO Add missing parents check here in case of deep nested value property!
                    // Or introduce AddressPersonHandling and utilize here!
                    // AddressPersonHandling.setContact(iter.previous(), value);
                    return;
                }
                throw new MissingTargetException("address.persons", targetId);
            }
         */
        List<?> propStackChild = propStackFromKey.call(keyChild)
        List<?> propStackArray = propStackFromKey.call(keyArray)
        List<?> propStackInner = propStackChild.subList(propStackArray.size(), propStackChild.size())
        def keyUpper = propStackChild.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        def keyUpperIntermediate = propStackArray.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        // in case of deep nested child
        def keyUpperInner = propStackInner.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        // in case of shallow child
        def setterName = upperCamelCase.call(propStackChild.last().name)

        def typeName = upperCamelCase.call(currentType.name)
        def typeNameIntermediate = upperCamelCase.call(propStackArray.last().type.type.name)
        def typeNameInner = upperCamelCase.call(propStackChild.last().type.type.name)
        // usually one of entryId, guid or refId!
        def idProp = upperCamelCase.call(findIdProperty.call(propStackArray.last()))
        def ret = """
    /**
     * Replaces the ${typeNameInner} of a specific ${typeNameIntermediate} object of a ${typeName}.
     * @param pojo The ${typeName} object to process
     * @param targetId The ID of the ${typeNameIntermediate}, which is to be altered.
     * @param value The ${typeNameInner} object to assign to the ${typeNameIntermediate}
     * @throws MissingTargetException if no ${typeNameIntermediate} of that id was found and subsequently altered,
     * @throws MissingParentException if
     *             <ul>
     *             <li> the attribute holding the ${typeNameIntermediate} objects or any of its parent objects is missing.</li>
     *             <li> the attribute holding the ${typeNameInner} objects or any of its parent objects is missing.</li>
     *             </ul>
     */
    public static void set${keyUpper}ById(final ${typeName} pojo, final UUID targetId,
            final ${typeNameInner} value) throws MissingParentException, MissingTargetException {
        final ListIterator<${typeNameIntermediate}> iter = get${keyUpperIntermediate}Throws(pojo).listIterator();
        while (iter.hasNext()) {
            if (iter.next().get${idProp}().equals(targetId)) {
                // in case of shallow ref or complex child:
                iter.previous().set${setterName}(value);
                // in case of deep nested ref or complex child:
                // TODO Add missing parents check here in case of deep nested value property!
                // Or introduce ${typeNameIntermediate}Handling and utilize here!
                // ${typeNameIntermediate}Handling.set${keyUpperInner}(iter.previous(), value);
                return;
            }
        }
        throw new MissingTargetException("${keyArray}", targetId);
    }"""
        return ret
    }

    /**
     * Prints the method removeXXX(pojo, UUID) associated with one key
     * of a nested array property.
     */
    Closure<String> printRemoveForKey = { String key ->
        List<?> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = upperCamelCase.call(currentType.name)
        // usually one of entryId, guid or refId!
        def idProp = upperCamelCase.call(findIdProperty.call(localPropStack.last()))
        def ret = """
    /**
     * Tries to remove a specific ${typeNameInner} object from a ${typeName}.
     * @param pojo The object to process
     * @param targetId The ID of the ${typeNameInner}, which is to be removed.
     * @return <i>True</i>, if a ${typeNameInner} of that id was found and subsequently removed,
     *         <i>false</i> if no object with that id could be found and therefore removed.
     */
    public static boolean remove${keyUpper}ById(${typeName} pojo, UUID targetId) {
        final Iterator<${typeNameInner}> iter = get${keyUpper}(pojo).iterator();
        while (iter.hasNext()) {
            if (iter.next().get${idProp}().equals(targetId)) {
                iter.remove();
                return true;
            }
        }
        return false;
    }"""
        return ret
    }

    /**
     * Prints the method void removeXXX(pojo, UUID) associated with one key
     * of a nested array property.
     */
    Closure<String> printRemoveForKeyThrows = { String key ->
        /*
            public static void removeLocationStreetsById(final JunctionJoined pojo, final UUID targetId)
                    throws MissingParentException, MissingTargetException {
                final Iterator<JunctionLocationStreetsItem> iter = getLocationStreetsThrows(pojo).iterator();
                while (iter.hasNext()) {
                    if (iter.next().getEntryId().equals(targetId)) {
                        iter.remove();
                        return;
                    }
                }
                throw new MissingTargetException("location.streets", targetId);
            }
         */
        List<?> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = upperCamelCase.call(currentType.name)
        // usually one of entryId, guid or refId!
        def idProp = upperCamelCase.call(findIdProperty.call(localPropStack.last()))
        def ret = """
    /**
     * Removes a specific ${typeNameInner} object from a ${typeName}.
     * @param pojo The object to process
     * @param targetId The ID of the ${typeNameInner}, which is to be removed.
     * @throws MissingTargetException if no ${typeNameInner} of that id was found and subsequently removed,
     * @throws MissingParentException if the attribute holding the ${typeNameInner} objects or any of its parent objects is
     *             missing.
     */
    public static void remove${keyUpper}ById(final ${typeName} pojo, final UUID targetId)
            throws MissingParentException, MissingTargetException {
        final Iterator<${typeNameInner}> iter = get${keyUpper}Throws(pojo).iterator();
        while (iter.hasNext()) {
            if (iter.next().get${idProp}().equals(targetId)) {
                iter.remove();
                return;
            }
        }
        throw new MissingTargetException("${key}", targetId);
    }"""
        return ret
    }

    /**
     * Actually creates the case of the getValue method for properties of a complex or reference class.
     * @param prop The property to process
     * @param lines Where the created lines of code are to be added.
     */
    def createGetValueSimple = { property, List<String> lines ->
        def parentCollection = propIsCollectionStack.last()
        def parentProp = propStack.empty ? null : propStack.last()
        def propStackParent = []; propStackParent.addAll(propStack)
        putStacks.call(property)
        def key = propStack.collect {prop -> prop.name}.join('.')
        def suffix = !joined && property.hasTag('prepLookup') ? 'Id' : ''
        if (verbose) println "type=${currentType.name} key=${key} parentCollection=${parentCollection} parCollClass=${parentCollection.class.getName()}"

        if (propStack.size() == 1) {
            // in case of normal type and tag 'prepLookup' add suffix Id to method name -> getObjectBaseId()!
            lines.add("""        case "${key}":
            return pojo.get${firstUpperCase.call(property.name)}${suffix}();""" )
        } else if (parentCollection) {
            // parent is collection: stream collection, map to value, collect(Collectors.toList())
            /* Example
                case "objectBase.gis.area.points.lon":
                    return getObjectBaseGisAreaPoints(target).stream().map(p -> p.getLon()).collect(Collectors.toList());
             */
            String methodName = propStackParent.collect{ prop -> upperCamelCase.call(prop.name) }.join('')
            String parentChar = parentProp.name.take(1)
            lines.add("""        case "${key}":
            return get${methodName}(pojo).stream().map(${parentChar} -> ${parentChar}.get${upperCamelCase.call(property.name)}${suffix}()).collect(Collectors.toList());""")
            // lines.add("""        case "${propStack.collect {prop -> prop.name}.join('.')}": return null; // TODO""" )
        } else {
            // parent not a collection: simple parent null check and return value
            /* Example:
                case "objectBase.gis.area.projection":
                    if (checkObjectBaseGisAreaExists(pojo)) {
                        return pojo.getObjectBase().getGis().getArea().getProjection();
                    } else {
                        return null;
                    }
             */
            String methodName = propStackParent.collect{ prop -> upperCamelCase.call(prop.name) }.join('')
            String getChain = propStack.collect{ prop -> upperCamelCase.call(prop.name) }.join('().get')

            lines.add("""        case "${key}":
            if (check${methodName}Exists(pojo)) {
                return pojo.get${getChain}${suffix}();
            } else {
                return null;
            }""" )
        }
        popStacks.call()
    }

    /** Forward declaration of closure, which calls itself! */
    def createGetValueForType

    /**
     * Creates the case statements of the getValue method for a certain type, calls itself recursively for reference
     * and complex types!
     * @param type The type to process
     * @param lines Where the created lines of code are to be added.
     */
    createGetValueForType = { type, List<String> lines ->
        filterProps.call(type, [refComplex:false]).each { prop ->
            if (verbose) println "// createGetValueForType/RefTypeOrComplexType=false: type=${type.name} prop=${prop.name}"
            createGetValueSimple.call(prop, lines)
        }
        filterProps.call(type, [refComplex:true]).each { prop ->
            createGetValueSimple.call(prop, lines)
            // recursive call!
            putStacks.call(prop)
            createGetValueForType.call(prop.type.type, lines)
            popStacks.call()
        }
    }

    // Forward declaration of closure, which calls itself!
    Closure<Integer> createEnsureMatchingForType

    /**
     * Creates the content of the method ensureMatchingEntryId for a certain type, calls itself recursively for reference
     * and complex types!
     * @param type The type to process
     * @param lines Where the created lines of code are to be added.
     */
    createEnsureMatchingForType = { type, List<String> lines, int idx ->
        // Track the number of increments of idx!
        int incCount = 0
        if (propIsCollectionStack.last()) {
            def pProp = propStack.last()
            boolean parentHasEntryId = pProp.isRefTypeOrComplexType() && pProp.type.type.properties.collect { prop2 -> prop2.name }.contains('entryId')
            if (parentHasEntryId) {
                /* Example
                final Iterator<AddressPerson> sourceIter1 = getAddressPersons(source).iterator();
                final Iterator<AddressPerson> targetIter1 = getAddressPersons(target).iterator();
                while(sourceIter1.hasNext()) {
                    targetIter1.next().setEntryId(sourceIter1.next().getEntryId());
                }
                */
                lines.add("        // found pProp=${pProp.name} type=${upperCamelCase.call(type.name)}")
                def jType = upperCamelCase.call(type.name)
                def methodName = propStack.collect { prop -> upperCamelCase.call(prop.name) }.join('')
                idx += 1
                incCount += 1
                lines.add(
"""        final Iterator<${jType}> sourceIter${idx} = get${methodName}(source).iterator();
        final Iterator<${jType}> targetIter${idx} = get${methodName}(target).iterator();
        while(sourceIter${idx}.hasNext()) {
            targetIter${idx}.next().setEntryId(sourceIter${idx}.next().getEntryId());
        }""")

            }
        }
        filterProps.call(type, [refComplex:true]).each { prop ->
            // recursive call!
            putStacks.call(prop)
            // idx may have been incremented 0 to n times by the recursive call!
            int recIncCount = createEnsureMatchingForType.call(prop.type.type, lines, idx)
            popStacks.call()
            idx += recIncCount
            incCount += recIncCount
        }
        return incCount
    }

    // Forward declaration of closure, which calls itself!
    def printCheckExistsForType

    /**
     * Prints the methods checkXXXExists(target) for a certain type, calls itself recursively for reference and complex types!
     * @param type The type to process
     */
    printCheckExistsForType = { type ->
        int size = propIsCollectionStack.size()
        if ( size > 2 && propIsCollectionStack.get(size-2)) {
            // can not check for null in children of array property -> stop creating more methods checkXXXExists()!
            return
        }
        if (!propStack.isEmpty()) {
            /*
                public static boolean checkObjectBaseGisAreaExists(JunctionNumberJoined target) {
                    return target.getObjectBase() != null
                            && target.getObjectBase().getGis() != null
                            && target.getObjectBase().getGis().getArea() != null;
                }
             */
            def checkMethodPart = propStack.collect{ upperCamelCase.call(it.name) }.join('')       // e.g. AddressPersonsContact
            // create longest getter call chain and then process it from one to all elements.
            List lines = []
            List getCalls = propStack.collect { "get${upperCamelCase.call(it.name)}()"}
            for (int i = 0; i < getCalls.size(); i++) {
                def cond = getCalls.subList(0, i+1).join('.')
                lines.add("target.${cond} != null")
            }
            def conditions = lines.join('\n                && ')
%>
    /**
     * @param target The object, which is to be processed.
     * @return <i>True</i>, if the attribute and all its parents exist, <i>false</i> otherwise.
     */
    public static boolean check${checkMethodPart}Exists(${targetType} target) {
        return ${conditions};
    }
<%
        }

//        type.properties.findAll { prop -> return prop.isRefTypeOrComplexType() }.each { prop ->
        filterProps.call(type, [refComplex:true]).each { prop ->
            // recursive call!
            putStacks.call(prop)
            printCheckExistsForType.call(prop.type.type)
            popStacks.call()
        }
    }

    // Forward declaration of closure, which calls itself!
    def printEnsureExistsForType

    /**
     * Prints the methods ensureXXXExists(target, boolean) for a certain type, calls itself recursively for reference and complex types!
     * @param type The type to process
     */
    printEnsureExistsForType = { type ->
        int size = propIsCollectionStack.size()
        if ( size > 2 && propIsCollectionStack.get(size-2)) {
            // can not check for null in children of array property -> stop creating more methods checkXXXExists()!
            return
        }
        if (!propStack.isEmpty()) {
            /*
                public static void ensureObjectBaseGisAreaPointsExists(JunctionJoined target, boolean isParent)
                        throws MissingParentException, MissingTargetException {
                    ensureObjectBaseGisAreaExists(target, true);
                    if (target.getObjectBase().getGis().getArea().getPoints() == null) {
                        if (isParent) {
                            throw new MissingParentException("objectBase.gis.area.points");
                        }
                        throw new MissingTargetException("objectBase.gis.area.points");
                    }
                }
             */
            def ensureMethodPart = propStack.collect{ upperCamelCase.call(it.name) }.join('')       // e.g. AddressPersonsContact
            def key = currentKey.call()
            List<String> getCalls = propStack.collect { "get${upperCamelCase.call(it.name)}()"}
            def getCall = getCalls.join('.')
            def parentCall
            int stackDim = propStack.size()
            if (stackDim == 1) {
                parentCall = ''
            } else {
                def ensureMethodPartParent = propStack.subList(0, stackDim-1).collect{ upperCamelCase.call(it.name) }.join('')
                parentCall = "\n        ensure${ensureMethodPartParent}Exists(target, false);"
            }
%>
    /**
     * Before performing an operation on an attribute like e.g. replacing or removing it, this method checks whether
     * that attribute and all its parent objects actually exist.
     * @param target The object, which is to be processed.
     * @param isParent Indicates whether the attribute is regarded as the target of the operation. This parameter
     *            controls, which Exception is emitted when all parent objects are available but the attribute itself is
     *            missing!
     * @throws MissingTargetException If the attribute is missing and parameter <i>isParent</i> indicates that it is
     *             regarded as the target of the operation.
     * @throws MissingParentException If either any of the parent objects of the attribute is missing or if the
     *             attribute itself is missing and parameter <i>isParent</i> indicates that the attribute is not
     *             regarded as the target of the operation.
     */
    public static void ensure${ensureMethodPart}Exists(${targetType} target, boolean isParent)
            throws MissingParentException, MissingTargetException {${parentCall}
        if (target.${getCall} == null) {
            if (isParent) {
                throw new MissingParentException("${key}");
            }
            throw new MissingTargetException("${key}");
        }
    }
<%
        }

//        type.properties.findAll { prop -> return prop.isRefTypeOrComplexType() }.each { prop ->
        filterProps.call(type, [refComplex:true]).each { prop ->
            // recursive call!
            putStacks.call(prop)
            printEnsureExistsForType.call(prop.type.type)
            popStacks.call()
        }
    }

    // Forward declaration of closure, which calls itself!
    def printGetForType

    /**
     * Prints the methods getXXX(target) (returning a list of objects) for a certain type, calls itself recursively for
     * reference and complex types!
     * @param type The type to process
     */
    printGetForType = { type ->
        if (propIsCollectionStack.last()) {
            // Example for key address.persons.contact where persons is the only array type
            // In case of multiple array types use .flatMap() for 2. to last array type!
            // We can not check for null references for objects in the object tree after hitting the first array property.
            // ->
            // A: the method checkXXXExists only checks for null references up to the first array property.
            // B: do use Stream.filter() with a predicate for filtering out the null references!
            /*
                public static List<ContactData> getAddressPersonsContact(JunctionContactJoined target) {
                    if (checkAddressPersonsExists(target)) {
                        return target.getAddress().getPersons().stream()
                                                               .filter(p -> p.getContact() != null)
                                                               .map(p -> p.getContact())
                                                               .collect(Collectors.toList());
                    }
                    return Collections.emptyList();
                }
             */
            def methodName = propStack.subList(0, propStack.size()).collect { upperCamelCase.call(it.name) }.join('') // e.g. AddressPersonsContact
            int maxCheckProp = propIsCollectionStack.last() ? propIsCollectionStack.indexOf(Boolean.TRUE) : propStack.size() // The index of the first entry of propIsCollectionStack indicating value collection
            def checkName = propStack.subList(0, maxCheckProp).collect { upperCamelCase.call(it.name) }.join('') // e.g. AddressPersons

            // iterate through propStack and propIsArrayStack
            // Before first array type is encountered, add getter calls
            // When first array type is encountered, add .stream() and switch mode to .map(...)
            // Whenever another array type is encountered, use .flatMap(...) instead of .map(...)
            List parts = []
            boolean useGetter = true
            for (int i = 0; i < propStack.size(); i++) {
                def currUpper = upperCamelCase.call(propStack[i].name)
                if (useGetter) {
                    // getXXX()
                    parts.add("get${currUpper}()")
                } else {
                    // TODO Teach Eiko and Stephan
                    def parentProp = propStack[i-1].name.take(1)
                    if (propIsArrayStack[i]) {
                        // flatMap(), e.g. flatMap(contact -> contact.getEmail().stream())
                        parts.add("filter(${parentProp} -> ${parentProp}.get${currUpper}() != null)")
                        parts.add("flatMap(${parentProp} -> ${parentProp}.get${currUpper}().stream())")
                    } else {
                        // map(), e.g. map(person -> person.getContact())
                        parts.add("filter(${parentProp} -> ${parentProp}.get${currUpper}() != null)")
                        parts.add("map(${parentProp} -> ${parentProp}.get${currUpper}())")
                    }
                }
                if (useGetter && propIsArrayStack[i]) {
                    parts.add("stream()")
                    useGetter = false
                }
            }
            parts.add('collect(Collectors.toList())')

            // If the very last entry is the first array type, then these is no need to appending
            // .stream() and .collect(Collectors.toList()) -> just discard these two entries!
            if (parts[parts.size()-2] == "stream()") {
                parts = parts.subList(0, parts.size() - 2)
            }
            def retType = upperCamelCase.call(type.name)
            def stream = parts[0] + parts.subList(1,parts.size()).collect {"\n                    .$it"}.join('')
%>
    /**
     * This method is lenient: It will always return at least an empty list, even if the parent objects of the
     * ${retType} are missing. Actions performed on the returned list will not change the state of the ${targetType}
     * object, changes to the ${retType} objects itself do change the ${targetType} object!
     * @param target The ${targetType} object to process
     * @return The ${retType} objects hold by the ${targetType} or an empty list, if the attribute holding the
     *         ${retType} objects or any of its parent objects is missing.
     */
    public static List<${retType}> get${methodName}(${targetType} target) {
        if (check${checkName}Exists(target)) {
            return target.${stream};
        }
        return Collections.emptyList();
    }
<%
        }

//        type.properties.findAll { prop -> return prop.isRefTypeOrComplexType() }.each { prop ->
        filterProps.call(type, [refComplex:true]).each { prop ->
            // recursive call!
            putStacks.call(prop)
            printGetForType.call(prop.type.type)
            popStacks.call()
        }
    }

    // Forward declaration of closure, which calls itself!
    def printGetThrowsForType

    /**
     * Prints the methods getXXXThrows(target) (returning a list of objects) for a certain type, calls itself
     * recursively for reference and complex types!
     * @param type The type to process
     */
    printGetThrowsForType = { type ->
        if (propIsCollectionStack.last()) {
            // Example for key address.persons.contact where persons is the only array type
            // In case of multiple array types use .flatMap() for 2. to last array type!
            // We can not check for null references for objects in the object tree after hitting the first array property.
            // ->
            // A: the method checkXXXExists only checks for null references up to the first array property.
            // B: do use Stream.filter() with a predicate for filtering out the null references!
            /*
                public static List<ContactData> getAddressPersonsContactThrows(JunctionContact target) throws MissingParentException {
                    // Assumption: List attributes are never null, only empty!
                    ensureAddressPersonsExists(target, true);
                    return target.getAddress()
                            .getPersons()
                            .stream()
                            .filter(p -> p.getContact() != null)
                            .map(p -> p.getContact())
                            .collect(Collectors.toList());
                }
             */
            def methodName = propStack.subList(0, propStack.size()).collect { upperCamelCase.call(it.name) }.join('') // e.g. AddressPersonsContact
            int maxCheckProp = propIsCollectionStack.last() ? propIsCollectionStack.indexOf(Boolean.TRUE) : propStack.size() // The index of the first entry of propIsCollectionStack indicating value collection
            def checkName = propStack.subList(0, maxCheckProp).collect { upperCamelCase.call(it.name) }.join('') // e.g. AddressPersons

            // iterate through propStack and propIsArrayStack
            // Before first array type is encountered, add getter calls
            // When first array type is encountered, add .stream() and switch mode to .map(...)
            // Whenever another array type is encountered, use .flatMap(...) instead of .map(...)
            List parts = []
            boolean useGetter = true
            for (int i = 0; i < propStack.size(); i++) {
                def currUpper = upperCamelCase.call(propStack[i].name)
                if (useGetter) {
                    // getXXX()
                    parts.add("get${currUpper}()")
                } else {
                    // TODO Teach Eiko and Stephan
                    def parentProp = propStack[i-1].name.take(1)
                    if (propIsArrayStack[i]) {
                        // flatMap(), e.g. flatMap(contact -> contact.getEmail().stream())
                        parts.add("filter(${parentProp} -> ${parentProp}.get${currUpper}() != null)")
                        parts.add("flatMap(${parentProp} -> ${parentProp}.get${currUpper}().stream())")
                    } else {
                        // map(), e.g. map(person -> person.getContact())
                        parts.add("filter(${parentProp} -> ${parentProp}.get${currUpper}() != null)")
                        parts.add("map(${parentProp} -> ${parentProp}.get${currUpper}())")
                    }
                }
                if (useGetter && propIsArrayStack[i]) {
                    parts.add("stream()")
                    useGetter = false
                }
            }
            parts.add('collect(Collectors.toList())')

            // If the very last entry is the first array type, then these is no need to appending
            // .stream() and .collect(Collectors.toList()) -> just discard these two entries!
            if (parts[parts.size()-2] == "stream()") {
                parts = parts.subList(0, parts.size() - 2)
            }
            def retType = upperCamelCase.call(type.name)
            def stream = parts[0] + parts.subList(1,parts.size()).collect {"\n                    .$it"}.join('')
%>
    /**
     * Actions performed on the returned list will not change the state of the ${targetType} object, changes to the
     * ${retType} objects itself do change the ${targetType} object!
     * @param target The ${targetType} object to process
     * @return The ${retType} objects hold by the ${targetType}
     * @throws MissingParentException if the attribute holding the ${retType} objects or any of its parent objects are
     *             missing.
     * @throws MissingTargetException Declared due to method reuse.
     */
    public static List<${retType}> get${methodName}Throws(${targetType} target) throws MissingParentException, MissingTargetException {
        // Assumption: List attributes are never null, only empty!
        ensure${checkName}Exists(target, true);
        return target.${stream};
    }
<%
        }

//        type.properties.findAll { prop -> return prop.isRefTypeOrComplexType() }.each { prop ->
        filterProps.call(type, [refComplex:true]).each { prop ->
            // recursive call!
            putStacks.call(prop)
            printGetThrowsForType.call(prop.type.type)
            popStacks.call()
        }
    }

    // Forward declaration of closure, which calls itself!
    def printGetSingleThrowsForType

    /**
     * Prints the methods getXXXThrows(target) (returning single object) for a certain type, calls itself recursively
     * for reference and complex types!
     * @param type The type to process
     */
    printGetSingleThrowsForType = { type ->
        int stackDim = propStack.size()
        if (stackDim > 0) {
            /*
                public static ObjectBaseGis getObjectBaseGisThrows(JunctionJoined target) throws MissingParentException {
                    ensureObjectBaseExists(target, true);
                    return target.getObjectBase().getGis();
                }
             */
            def methodName = propStack.collect { upperCamelCase.call(it.name) }.join('') // e.g. ObjectBaseGis
            def checkName = propStack.subList(0, stackDim - 1).collect { upperCamelCase.call(it.name) }.join('') // e.g. ObjectBase
            def checkLine = stackDim > 1 ? "\n        ensure${checkName}Exists(target, true);" : ''
            def getterChain = 'get' + propStack.collect { upperCamelCase.call(it.name) }.join('().get') + '()' // e.g. getObjectBase().getGis()
            def retType = upperCamelCase.call(type.name)
%>
    /**
     * @param target The ${targetType} object to process
     * @return The ${retType} object hold by the ${targetType}
     * @throws MissingParentException if the attribute holding the ${retType} objects or any of its parent objects is
     *             missing.
     * @throws MissingTargetException Declared due to method reuse.
     */
    public static ${retType} get${methodName}Throws(${targetType} target) throws MissingParentException, MissingTargetException {${checkLine}
        return target.${getterChain};
    }
<%
        }

        filterProps.call(type, [refComplex:true, array:false]).each { prop ->
            // recursive call!
            putStacks.call(prop)
            printGetSingleThrowsForType.call(prop.type.type)
            popStacks.call()
        }
    }

    // Forward declaration of closure, which calls itself!
    def printSetSingleForType
    
    /**
     * Prints the methods setXXX(target, replacement) throws MissingParentException for a certain type, calls itself recursively
     * for reference and complex types!
     * @param type The type to process
     */
    printSetSingleForType = { type ->
        int stackDim = propStack.size()
        if (stackDim > 1) {
            /*
                public static void setObjectBaseGisArea(JunctionJoined target, GeoArea replacement) throws MissingParentException {
                    ensureObjectBaseGisExists(target, true);
                    target.getObjectBase().getGis().setArea(replacement);
                }
             */
            def methodName = propStack.collect { upperCamelCase.call(it.name) }.join('') // e.g. ObjectBaseGisArea
            def typeNameInner = upperCamelCase.call(propStack.last().type.type.name)
            List<?> parentStack = propStack.subList(0, stackDim - 1)
            def checkName = parentStack.collect { upperCamelCase.call(it.name) }.join('') // e.g. ObjectBaseGis
            def getterChain = 'get' + parentStack.collect { upperCamelCase.call(it.name) }.join('().get') + '()' // e.g. getObjectBase().getGis()
            def setterName = upperCamelCase.call(propStack.last().name) // e.g. Area
%>
    /**
     * @param target The ${targetType} object to process
     * @param replacement The ${typeNameInner} object to assign to the ${targetType}
     * @throws MissingParentException if the attribute holding the ${typeNameInner} objects or any of its parent objects is
     *             missing.
     * @throws MissingTargetException Declared due to method reuse.
     */
    public static void set${methodName}(${targetType} target, ${typeNameInner} replacement) throws MissingParentException, MissingTargetException {
        ensure${checkName}Exists(target, true);
        target.${getterChain}.set${setterName}(replacement);
    }
<%
        }

        filterProps.call(type, [refComplex:true, array:false]).each { prop ->
            // recursive call!
            putStacks.call(prop)
            printSetSingleForType.call(prop.type.type)
            popStacks.call()
        }
    }

    /**
     * Print add methods for deep nested array properties. Utilizes other handling classes!
     * @param key The key to process
     */
    Closure<String> printAddOtherHandlingForKey = { String key ->
        /*
             public static void addSubIntersectionsFlowLegsApproachLanesSignalGroups(final JunctionFlowDiagram item0,
                    final UUID subIntersectionFlow_id, final UUID leg_id, final UUID lane_id, final SignalGroup additional)
                    throws MissingParentException, MissingTargetException {
                final SubIntersectionFlow item1 = getSubIntersectionsFlowById(item0, subIntersectionFlow_id);
                final Leg item2 = SubIntersectionFlowHandling.getLegsById(item1, leg_id);
                final Lane item3 = LegHandling.getApproachLanesById(item2, lane_id);
                LaneHandling.addSignalGroups(item3, additional);
            }
         */
        if (verbose) println "// printAddOtherHandlingForKey for key $key"
        List<?> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = upperCamelCase.call(currentType.name)
        // List of array properties
        List<?> arrayProps = localPropStack.findAll { prop -> prop.type.isArray }

        // Collect method parameter of type UUID
        List<?> paramProps = arrayProps.clone()
        // If one element is to be added/replaced/removed to deepest array, drop it's UUID from parameter list!
        if (localPropStack.last().type.isArray) {
            paramProps.pop()
        }
        def idList = paramProps.collect { prop -> "final UUID ${ lowerCamelCase.call(prop.type.type.name) }_id"}.join(', ')

        // Collect prop stacks for calls XXXHandling.getYYYById(itemI, id_I+1)
        // and prop stack for calling final XXXHandling.addYYY(item, additional)
        // If an element is to be added to an array, then that part ends up in the addPropStack
        List<List<?>> innerPropStacks = partitionArrayPros.call(localPropStack)
        List<?> addPropStack = innerPropStacks.pop()
        List<?> firstGetPropStack = innerPropStacks.remove(0)

        List<String> lines = []
        List<String> javaDocLines = []
        /*
         * subIntersectionsFlow ->
         * final SubIntersectionFlow item1 = getSubIntersectionsFlowById(itme0, subIntersectionFlow_id);
         */
        // String firstGetLine = "firstGet: ${ firstGetPropStack.collect{ it.name }.join('.')}"
        def firstItemProp = firstGetPropStack.last()
        String firstGetter = firstGetPropStack.collect { upperCamelCase.call(it.name) }.join('')
        String firstItemId = lowerCamelCase.call(firstItemProp.type.type.name) + '_id'
        String firstItemClass = upperCamelCase.call(firstItemProp.type.type.name)
        String firstGetLine = "final ${ firstItemClass } item1 = get${firstGetter}ById(item0, ${ firstItemId });"
        lines.add(firstGetLine)
        javaDocLines.add("@param ${ firstItemId } The ID of the ${ firstItemClass } object, which is to be selected")

        int itemIdx = 1
        /*
         * getBy: subIntersectionsFlow.legs ->
         * final Leg item2 = SubIntersectionFlowHandling.getLegsById(item1, leg_id);
         * getBy: legs.approachLanes ->
         * final Lane item3 = LegHandling.getApproachLanesById(item2, leg_id);
         */
        // innerPropStacks.each { stack -> lines.add("getBy: ${stack.collect { it.name}.join('.') }")}
        innerPropStacks.each { stack ->
            def innerHandlerProp = stack.remove(0)
            def innerItemProp = stack.last()
            String innerGetter = stack.collect { upperCamelCase.call(it.name) }.join('')
            String itemId = lowerCamelCase.call(innerItemProp.type.type.name) + '_id'
            String itemClass = upperCamelCase.call(innerItemProp.type.type.name)
            lines.add("final ${ itemClass } item${itemIdx+1} = ${ upperCamelCase.call(innerHandlerProp.type.type.name) }Handling.get${innerGetter}ById(item${itemIdx}, ${ itemId });")
            // e.g. @param leg_id The ID of the Leg object, which is to be selected
            javaDocLines.add("@param ${ itemId } The ID of the ${ itemClass } object, which is to be selected")
            itemIdx++
        }

        /*
         * approachLanes.trafficIsland ->
         * item3.setTrafficIsland(additional);
         * approachLanes.signalGroups ->
         * LaneHandling.addSignalGroups(item3, additional);
         */
        // String finalAddLine = "finalAdd: ${ addPropStack.collect{ it.name }.join('.')}"
        boolean setValue = addPropStack.size() == 2 && !addPropStack.last().type.isArray
        def lastHanderlProp = addPropStack.remove(0)
        String addChain = addPropStack.collect { upperCamelCase.call(it.name) }.join('')
        String finalAddLine
        if (setValue) {
            finalAddLine = "item${ itemIdx }.set${ addChain }(additional);"
        } else {
            finalAddLine = "${ upperCamelCase.call(lastHanderlProp.type.type.name) }Handling.add${ addChain }(item${ itemIdx }, additional);"
        }
        lines.add(finalAddLine)

        String inner = lines.join('\n        ')
        String idJavaDocLines = javaDocLines.isEmpty() ? '' : '\n     * ' + javaDocLines.join('\n     * ')

        def ret = """
    /**
     * Adds a ${typeNameInner} object to a ${typeName}.
     * @param pojo the parent object to extend${idJavaDocLines}
     * @param additional The ${typeNameInner} object to add to the ${typeName}
     * @throws MissingTargetException if the attribute holding the ${typeNameInner} objects is null
     * @throws MissingParentException if any parent of the attribute holding the ${typeNameInner} objects is missing.
     *             missing.
     */
    public static void add${keyUpper}(final ${typeName} item0, ${idList}, final ${typeNameInner} additional)
            throws MissingParentException, MissingTargetException {
        ${inner}
    }"""
        return ret
    }

    /**
     * Print get single item methods for deep nested array properties. Utilizes other handling classes!
     * @param key The key to process
     */
    Closure<String> printGetByIdOtherHandlingForKey = { String key ->
        /*
            public static SignalGroup getSubIntersectionsFlowLegsApproachLanesSignalGroupsById(final JunctionFlowDiagram item0,
                    final UUID subIntersectionFlow_id, final UUID leg_id, final UUID lane_id, final UUID signalGroup_id)
                    throws MissingParentException, MissingTargetException {
                final SubIntersectionFlow item1 = getSubIntersectionsFlowById(item0, subIntersectionFlow_id);
                final Leg item2 = SubIntersectionFlowHandling.getLegsById(item1, leg_id);
                final Lane item3 = LegHandling.getApproachLanesById(item2, lane_id);
                return LaneHandling.getSignalGroupsById(item3, signalGroup_id);
            }
         */
        if (verbose) println "// printGetByIdOtherHandlingForKey for key $key"
        List<?> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = upperCamelCase.call(currentType.name)
        // List of array properties
        List<?> arrayProps = localPropStack.findAll { prop -> prop.type.isArray }

        // Collect method parameter of type UUID
        List<?> paramProps = arrayProps.clone()
        def idList = paramProps.collect { prop -> "final UUID ${ lowerCamelCase.call(prop.type.type.name) }_id"}.join(', ')

        // Collect prop stacks for calls XXXHandling.getYYYById(itemI, id_I+1)
        // and prop stack for calling final XXXHandling.addYYY(item, additional)
        // If an element is to be added to an array, then that part ends up in the addPropStack
        List<List<?>> innerPropStacks = partitionArrayPros.call(localPropStack)
        List<?> lastGetPropStack = innerPropStacks.pop()
        List<?> firstGetPropStack = innerPropStacks.remove(0)

        List<String> lines = []
        List<String> javaDocLines = []
        /*
         * subIntersectionsFlow ->
         * final SubIntersectionFlow item1 = getSubIntersectionsFlowById(itme0, subIntersectionFlow_id);
         */
        // String firstGetLine = "// firstGet: ${ firstGetPropStack.collect{ it.name }.join('.')}"
        def firstItemProp = firstGetPropStack.last()
        String firstGetter = firstGetPropStack.collect { upperCamelCase.call(it.name) }.join('')
        String firstItemId = lowerCamelCase.call(firstItemProp.type.type.name) + '_id'
        String firstItemClass = upperCamelCase.call(firstItemProp.type.type.name)
        String firstGetLine = "final ${ firstItemClass } item1 = get${firstGetter}ById(item0, ${ firstItemId });"
        lines.add(firstGetLine)
        javaDocLines.add("@param ${ firstItemId } The ID of the ${ firstItemClass } object, which is to be selected")

        int itemIdx = 1
        /*
         * getBy: subIntersectionsFlow.legs ->
         * final Leg item2 = SubIntersectionFlowHandling.getLegsById(item1, leg_id);
         * getBy: legs.approachLanes ->
         * final Lane item3 = LegHandling.getApproachLanesById(item2, leg_id);
         */
        // innerPropStacks.each { stack -> lines.add("// getBy: ${stack.collect { it.name}.join('.') }")}
        innerPropStacks.each { stack ->
            def innerHandlerProp = stack.remove(0)
            def innerItemProp = stack.last()
            String innerGetter = stack.collect { upperCamelCase.call(it.name) }.join('')
            String itemId = lowerCamelCase.call(innerItemProp.type.type.name) + '_id'
            String itemClass = upperCamelCase.call(innerItemProp.type.type.name)
            lines.add("final ${ itemClass } item${itemIdx+1} = ${ upperCamelCase.call(innerHandlerProp.type.type.name) }Handling.get${innerGetter}ById(item${itemIdx}, ${ itemId });")
            // e.g. @param leg_id The ID of the Leg object, which is to be selected
            javaDocLines.add("@param ${ itemId } The ID of the ${ itemClass } object, which is to be selected")
            itemIdx++
        }

        /*
         * approachLanes.trafficIsland ->
         * return item3.getTrafficIsland();
         * approachLanes.signalGroups ->
         * return LaneHandling.getSignalGroupsById(item3, signalGroup_id);
         */
        // String finalGetLine = "// finalGet: ${ lastGetPropStack.collect{ it.name }.join('.')}"
        // lines.add(finalGetLine)
        // lines.add('return null;')
        def lastProperty = lastGetPropStack.last()
        boolean getValue = lastGetPropStack.size() == 2 && !lastProperty.type.isArray
        def lastHandlerProp = lastGetPropStack.remove(0)
        String addChain = lastGetPropStack.collect { upperCamelCase.call(it.name) }.join('')
        String finalGetLine
        if (getValue) {
            finalGetLine = "return item${ itemIdx }.get${ addChain }();"
        } else {
            String lastItemId = lowerCamelCase.call(lastProperty.type.type.name) + '_id'
            String lastItemClass = upperCamelCase.call(lastProperty.type.type.name)
            finalGetLine = "return ${ upperCamelCase.call(lastHandlerProp.type.type.name) }Handling.get${ addChain }ById(item${ itemIdx }, ${lastItemId});"
            javaDocLines.add("@param ${ lastItemId } The ID of the ${ lastItemClass } object, which is to be selected")

        }
        lines.add(finalGetLine)

        String inner = lines.join('\n        ')
        String idJavaDocLines = javaDocLines.isEmpty() ? '' : '\n     * ' + javaDocLines.join('\n     * ')

        def ret = """
    /**
     * Returns a specific ${typeNameInner} object from a ${typeName}.
     * @param item0 the ${typeName} object to process${idJavaDocLines}
     * @throws MissingTargetException if no ${typeNameInner} of that id was found and subsequently returned.
     * @throws MissingParentException if the attribute holding the ${typeNameInner} objects or any of its parent objects is missing.
     */
    public static ${typeNameInner} get${keyUpper}ById(final ${typeName} item0, ${idList})
            throws MissingParentException, MissingTargetException {
        ${inner}
    }"""
        return ret
    }

    /**
     * Print get methods for deep nested array properties, returning all objects of the array. Utilizes other handling classes!
     * @param key The key to process
     */
    Closure<String> printGetThrowsOtherHandlingForKey = { String key ->
        /*
            public static List<SignalGroup> getSubIntersectionsFlowLegsApproachLanesSignalGroupsThrows(final JunctionFlowDiagram item0,
                    final UUID subIntersectionFlow_id, final UUID leg_id, final UUID lane_id)
                    throws MissingParentException, MissingTargetException {
                final SubIntersectionFlow item1 = getSubIntersectionsFlowById(item0, subIntersectionFlow_id);
                final Leg item2 = SubIntersectionFlowHandling.getLegsById(item1, leg_id);
                final Lane item3 = LegHandling.getApproachLanesById(item2, lane_id);
                return LaneHandling.getSignalGroups(item3);
            }
         */
        if (verbose) println "// printGetThrowsOtherHandlingForKey for key $key"
        List<?> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = upperCamelCase.call(currentType.name)
        // List of array properties
        List<?> arrayProps = localPropStack.findAll { prop -> prop.type.isArray }

        // Collect method parameter of type UUID
        List<?> paramProps = arrayProps.clone()
        paramProps.pop()
        def idList = paramProps.collect { prop -> "final UUID ${ lowerCamelCase.call(prop.type.type.name) }_id"}.join(', ')

        // Collect prop stacks for calls XXXHandling.getYYYById(itemI, id_I+1)
        // and prop stack for calling final XXXHandling.addYYY(item, additional)
        // If an element is to be added to an array, then that part ends up in the addPropStack
        List<List<?>> innerPropStacks = partitionArrayPros.call(localPropStack)
        List<?> lastGetPropStack = innerPropStacks.pop()
        List<?> firstGetPropStack = innerPropStacks.remove(0)

        List<String> lines = []
        List<String> javaDocLines = []
        /*
         * subIntersectionsFlow ->
         * final SubIntersectionFlow item1 = getSubIntersectionsFlowById(itme0, subIntersectionFlow_id);
         */
        // String firstGetLine = "// firstGet: ${ firstGetPropStack.collect{ it.name }.join('.')}"
        // lines.add(firstGetLine)

        def firstItemProp = firstGetPropStack.last()
        String firstGetter = firstGetPropStack.collect { upperCamelCase.call(it.name) }.join('')
        String firstItemId = lowerCamelCase.call(firstItemProp.type.type.name) + '_id'
        String firstItemClass = upperCamelCase.call(firstItemProp.type.type.name)
        String firstGetLine = "final ${ firstItemClass } item1 = get${firstGetter}ById(item0, ${ firstItemId });"
        lines.add(firstGetLine)
        javaDocLines.add("@param ${ firstItemId } The ID of the ${ firstItemClass } object, which is to be selected")

        int itemIdx = 1
        /*
         * getBy: subIntersectionsFlow.legs ->
         * final Leg item2 = SubIntersectionFlowHandling.getLegsById(item1, leg_id);
         * getBy: legs.approachLanes ->
         * final Lane item3 = LegHandling.getApproachLanesById(item2, leg_id);
         */
        // innerPropStacks.each { stack -> lines.add("// getBy: ${stack.collect { it.name}.join('.') }")}
        innerPropStacks.each { stack ->
            def innerHandlerProp = stack.remove(0)
            def innerItemProp = stack.last()
            String innerGetter = stack.collect { upperCamelCase.call(it.name) }.join('')
            String itemId = lowerCamelCase.call(innerItemProp.type.type.name) + '_id'
            String itemClass = upperCamelCase.call(innerItemProp.type.type.name)
            lines.add("final ${ itemClass } item${itemIdx+1} = ${ upperCamelCase.call(innerHandlerProp.type.type.name) }Handling.get${innerGetter}ById(item${itemIdx}, ${ itemId });")
            // e.g. @param leg_id The ID of the Leg object, which is to be selected
            javaDocLines.add("@param ${ itemId } The ID of the ${ itemClass } object, which is to be selected")
            itemIdx++
        }

        /*
         * approachLanes.trafficIsland ->
         * return item3.getTrafficIsland();
         * approachLanes.signalGroups ->
         * return LaneHandling.getSignalGroupsById(item3, signalGroup_id);
         */
        // String finalGetLine = "// finalGet: ${ lastGetPropStack.collect{ it.name }.join('.')}"
        // ines.add(finalGetLine)
        // ines.add('return null;')
        def lastProperty = lastGetPropStack.last()
        boolean getValue = lastGetPropStack.size() == 2 && !lastProperty.type.isArray
        def lastHandlerProp = lastGetPropStack.remove(0)
        String addChain = lastGetPropStack.collect { upperCamelCase.call(it.name) }.join('')
        String finalGetLine
        if (getValue) {
            finalGetLine = "return item${ itemIdx }.get${ addChain }();"
        } else {
            finalGetLine = "return ${ upperCamelCase.call(lastHandlerProp.type.type.name) }Handling.get${ addChain }(item${ itemIdx });"
        }
        lines.add(finalGetLine)

        String inner = lines.join('\n        ')
        String idJavaDocLines = javaDocLines.isEmpty() ? '' : '\n     * ' + javaDocLines.join('\n     * ')
        String typeParent = upperCamelCase.call(paramProps.last().type.type.name)

        def ret = """
    /**
     * Returns all ${typeNameInner} object hold by a special ${typeParent} object of an ${typeName}.
     * @param item0 the ${typeName} object to process${idJavaDocLines}
     * @throws MissingTargetException if no ${typeNameInner} of that id was found and subsequently returned.
     * @throws MissingParentException if the attribute holding the ${typeNameInner} objects or any of its parent objects is missing.
     */
    public static List<${typeNameInner}> get${keyUpper}Throws(final ${typeName} item0, ${idList})
            throws MissingParentException, MissingTargetException {
        ${inner}
    }"""
        return ret
    }

    /**
     * Print replace single item methods for deep nested array properties. Utilizes other handling classes!
     * @param key The key to process
     */
    Closure<String> printReplaceByIdOtherHandlingForKey = { String key ->
        /*
            public static void replaceSubIntersectionsFlowLegsApproachLanesById(final JunctionFlowDiagram item0,
                    final UUID subIntersectionFlow_id, final UUID leg_id, final UUID lane_id, Lane bodyParam)
                    throws MissingParentException, MissingTargetException {
                final SubIntersectionFlow item1 = getSubIntersectionsFlowById(item0, subIntersectionFlow_id);
                final Leg item2 = SubIntersectionFlowHandling.getLegsById(item1, leg_id);
                LegHandling.replaceApproachLanesById(item2, lane_id, bodyParam);
            }
         */
        if (verbose) println "// printReplaceByIdOtherHandlingForKey for key $key"
        List<?> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = upperCamelCase.call(currentType.name)
        // List of array properties
        List<?> arrayProps = localPropStack.findAll { prop -> prop.type.isArray }

        // Collect method parameter of type UUID
        List<?> paramProps = arrayProps.clone()
        def idList = paramProps.collect { prop -> "final UUID ${ lowerCamelCase.call(prop.type.type.name) }_id"}.join(', ')

        // Collect prop stacks for calls XXXHandling.getYYYById(itemI, id_I+1)
        // and prop stack for calling final XXXHandling.addYYY(item, additional)
        // If an element is to be added to an array, then that part ends up in the addPropStack
        List<List<?>> innerPropStacks = partitionArrayPros.call(localPropStack)
        List<?> lastReplacePropStack = innerPropStacks.pop()
        List<?> firstGetPropStack = innerPropStacks.remove(0)

        List<String> lines = []
        List<String> javaDocLines = []
        /*
         * subIntersectionsFlow ->
         * final SubIntersectionFlow item1 = getSubIntersectionsFlowById(itme0, subIntersectionFlow_id);
         */
        // String firstGetLine = "// firstGet: ${ firstGetPropStack.collect{ it.name }.join('.')}"
        // lines.add(firstGetLine)
        def firstItemProp = firstGetPropStack.last()
        String firstGetter = firstGetPropStack.collect { upperCamelCase.call(it.name) }.join('')
        String firstItemId = lowerCamelCase.call(firstItemProp.type.type.name) + '_id'
        String firstItemClass = upperCamelCase.call(firstItemProp.type.type.name)
        String firstGetLine = "final ${ firstItemClass } item1 = get${firstGetter}ById(item0, ${ firstItemId });"
        lines.add(firstGetLine)
        javaDocLines.add("@param ${ firstItemId } The ID of the ${ firstItemClass } object, which is to be selected")

        int itemIdx = 1
        /*
         * getBy: subIntersectionsFlow.legs ->
         * final Leg item2 = SubIntersectionFlowHandling.getLegsById(item1, leg_id);
         * getBy: legs.approachLanes ->
         * final Lane item3 = LegHandling.getApproachLanesById(item2, leg_id);
         */
        // innerPropStacks.each { stack -> lines.add("// getBy: ${stack.collect { it.name}.join('.') }")}
        innerPropStacks.each { stack ->
            def innerHandlerProp = stack.remove(0)
            def innerItemProp = stack.last()
            String innerGetter = stack.collect { upperCamelCase.call(it.name) }.join('')
            String itemId = lowerCamelCase.call(innerItemProp.type.type.name) + '_id'
            String itemClass = upperCamelCase.call(innerItemProp.type.type.name)
            lines.add("final ${ itemClass } item${itemIdx+1} = ${ upperCamelCase.call(innerHandlerProp.type.type.name) }Handling.get${innerGetter}ById(item${itemIdx}, ${ itemId });")
            // e.g. @param leg_id The ID of the Leg object, which is to be selected
            javaDocLines.add("@param ${ itemId } The ID of the ${ itemClass } object, which is to be selected")
            itemIdx++
        }

        /*
         * approachLanes.trafficIsland ->
         * return item3.setTrafficIsland(bodyParam);
         * approachLanes.signalGroups ->
         * return LaneHandling.replaceSignalGroupsById(item3, signalGroup_id, bodyParam);
         */
        // String finalReplaceLine = "// finalReplace: ${ lastReplacePropStack.collect{ it.name }.join('.')}"
        // lines.add(finalReplaceLine)
        def lastProperty = lastReplacePropStack.last()
        boolean setValue = lastReplacePropStack.size() == 2 && !lastProperty.type.isArray
        def lastHandlerProp = lastReplacePropStack.remove(0)
        String addChain = lastReplacePropStack.collect { upperCamelCase.call(it.name) }.join('')
        String finalReplaceLine
        if (setValue) {
            finalReplaceLine = "item${ itemIdx }.set${ addChain }(bodyParam);"
        } else {
            String lastItemId = lowerCamelCase.call(lastProperty.type.type.name) + '_id'
            String lastItemClass = upperCamelCase.call(lastProperty.type.type.name)
            finalReplaceLine = "${ upperCamelCase.call(lastHandlerProp.type.type.name) }Handling.replace${ addChain }ById(item${ itemIdx }, ${lastItemId}, bodyParam);"
            javaDocLines.add("@param ${ lastItemId } The ID of the ${ lastItemClass } object, which is to be replaced")

        }
        lines.add(finalReplaceLine)

        String inner = lines.join('\n        ')
        String idJavaDocLines = javaDocLines.isEmpty() ? '' : '\n     * ' + javaDocLines.join('\n     * ')

        def ret = """
    /**
     * Replaces a specific ${typeNameInner} object of a ${typeName}.
     * @param item0 the ${typeName} object to process${idJavaDocLines}
     * @param bodyParam The ${typeNameInner} object to assign to the ${typeName} 
     * @throws MissingTargetException if no ${typeNameInner} of that id was found and subsequently replaced.
     * @throws MissingParentException if the attribute holding the ${typeNameInner} objects or any of its parent objects is missing.
     */
    public static void replace${keyUpper}ById(final ${typeName} item0, ${idList}, final ${typeNameInner} bodyParam)
            throws MissingParentException, MissingTargetException {
        ${inner}
    }"""
        return ret
    }

    /**
     * Print remove single item methods for deep nested array properties. Utilizes other handling classes!
     * @param key The key to process
     */
    Closure<String> printRemoveByIdOtherHandlingForKey = { String key ->
        /*
            public static void removeSubIntersectionsFlowLegsApproachLanesById(final JunctionFlowDiagram item0,
                    final UUID subIntersectionFlow_id, final UUID leg_id, final UUID lane_id)
                    throws MissingParentException, MissingTargetException {
                final SubIntersectionFlow item1 = getSubIntersectionsFlowById(item0, subIntersectionFlow_id);
                final Leg item2 = SubIntersectionFlowHandling.getLegsById(item1, leg_id);
                LegHandling.removeApproachLanesById(item2, lane_id);
            }
         */
        if (verbose) println "// printRemoveByIdOtherHandlingForKey for key $key"
        List<?> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = upperCamelCase.call(currentType.name)
        // List of array properties
        List<?> arrayProps = localPropStack.findAll { prop -> prop.type.isArray }

        // Collect method parameter of type UUID
        List<?> paramProps = arrayProps.clone()
        def idList = paramProps.collect { prop -> "final UUID ${ lowerCamelCase.call(prop.type.type.name) }_id"}.join(', ')

        // Collect prop stacks for calls XXXHandling.getYYYById(itemI, id_I+1)
        // and prop stack for calling final XXXHandling.addYYY(item, additional)
        // If an element is to be added to an array, then that part ends up in the addPropStack
        List<List<?>> innerPropStacks = partitionArrayPros.call(localPropStack)
        List<?> lastPropStack = innerPropStacks.pop()
        List<?> firstGetPropStack = innerPropStacks.remove(0)

        List<String> lines = []
        List<String> javaDocLines = []
        /*
         * subIntersectionsFlow ->
         * final SubIntersectionFlow item1 = getSubIntersectionsFlowById(itme0, subIntersectionFlow_id);
         */
        // String firstGetLine = "// firstGet: ${ firstGetPropStack.collect{ it.name }.join('.')}"
        // lines.add(firstGetLine)
        def firstItemProp = firstGetPropStack.last()
        String firstGetter = firstGetPropStack.collect { upperCamelCase.call(it.name) }.join('')
        String firstItemId = lowerCamelCase.call(firstItemProp.type.type.name) + '_id'
        String firstItemClass = upperCamelCase.call(firstItemProp.type.type.name)
        String firstGetLine = "final ${ firstItemClass } item1 = get${firstGetter}ById(item0, ${ firstItemId });"
        lines.add(firstGetLine)
        javaDocLines.add("@param ${ firstItemId } The ID of the ${ firstItemClass } object, which is to be selected")

        int itemIdx = 1
        /*
         * getBy: subIntersectionsFlow.legs ->
         * final Leg item2 = SubIntersectionFlowHandling.getLegsById(item1, leg_id);
         * getBy: legs.approachLanes ->
         * final Lane item3 = LegHandling.getApproachLanesById(item2, leg_id);
         */
        // innerPropStacks.each { stack -> lines.add("// getBy: ${stack.collect { it.name}.join('.') }")}
        innerPropStacks.each { stack ->
            def innerHandlerProp = stack.remove(0)
            def innerItemProp = stack.last()
            String innerGetter = stack.collect { upperCamelCase.call(it.name) }.join('')
            String itemId = lowerCamelCase.call(innerItemProp.type.type.name) + '_id'
            String itemClass = upperCamelCase.call(innerItemProp.type.type.name)
            lines.add("final ${ itemClass } item${itemIdx+1} = ${ upperCamelCase.call(innerHandlerProp.type.type.name) }Handling.get${innerGetter}ById(item${itemIdx}, ${ itemId });")
            // e.g. @param leg_id The ID of the Leg object, which is to be selected
            javaDocLines.add("@param ${ itemId } The ID of the ${ itemClass } object, which is to be selected")
            itemIdx++
        }

        /*
         * approachLanes.trafficIsland ->
         * return item3.setTrafficIsland(null);
         * approachLanes.signalGroups ->
         * return LaneHandling.removeSignalGroupsById(item3, signalGroup_id);
         */
        // String finalRemoveLine = "// finalReplace: ${ lastPropStack.collect{ it.name }.join('.')}"
        // lines.add(finalRemoveLine)
        def lastProperty = lastPropStack.last()
        boolean setValue = lastPropStack.size() == 2 && !lastProperty.type.isArray
        def lastHandlerProp = lastPropStack.remove(0)
        String addChain = lastPropStack.collect { upperCamelCase.call(it.name) }.join('')
        String finalRemoveLine
        if (setValue) {
            finalRemoveLine = "item${ itemIdx }.set${ addChain }(null);"
        } else {
            String lastItemId = lowerCamelCase.call(lastProperty.type.type.name) + '_id'
            String lastItemClass = upperCamelCase.call(lastProperty.type.type.name)
            finalRemoveLine = "${ upperCamelCase.call(lastHandlerProp.type.type.name) }Handling.remove${ addChain }ById(item${ itemIdx }, ${lastItemId});"
            javaDocLines.add("@param ${ lastItemId } The ID of the ${ lastItemClass } object, which is to be removed")

        }
        lines.add(finalRemoveLine)

        String inner = lines.join('\n        ')
        String idJavaDocLines = javaDocLines.isEmpty() ? '' : '\n     * ' + javaDocLines.join('\n     * ')

        def ret = """
    /**
     * Removes a specific ${typeNameInner} object of a ${typeName}.
     * @param item0 the ${typeName} object to process${idJavaDocLines} 
     * @throws MissingTargetException if no ${typeNameInner} of that id was found and subsequently removed.
     * @throws MissingParentException if the attribute holding the ${typeNameInner} objects or any of its parent objects is missing.
     */
    public static void remove${keyUpper}ById(final ${typeName} item0, ${idList})
            throws MissingParentException, MissingTargetException {
        ${inner}
    }"""
        return ret
    }

    // Create a private copy of the current type and alter that: tune prepLookup properties to loose suffix Id!
    def tunedType = copyType.call(currentType)
    tuneType.call(tunedType)

    // find keys for methods, where another Handling class needs to be called
    // -> find array of ref or complex properties contained by array of ref or complex type
    List<String> otherHandlingKeys = evalOtherHandlingKeysForType.call(tunedType)
    // find keys for methods, where another Handling class needs to be called
    // -> find array of ref or complex properties contained by array of ref or complex type - ignore children unless they lead to another relevant array
    List<String> otherHandlingKeysForArray = evalOtherHandlingKeysForArraysForType.call(tunedType)

    // find keys for method removeXXXById(pojo, targetId) -> find array of ref or complex properties
    List<String> deepNestedListKeys = evalDeepNestedListKeysForType.call(tunedType)
    // find keys for method setXXXById(pojo, targetId, value) -> find ref or complex children of arrays of ref or complex properties
    Map<String, String> deepNestedList2SingleChildKeys = evalDeepNestedListChildKeysForType.call(tunedType, deepNestedListKeys)
%>package de.lisaplus.lisa.${extraParam.serviceBase}.model.handling;

/*
 * This file is generated by jsonCodeGen. Changes will be overwritten with next code generation run.
 * Template: handling.txt
 */

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.UUID;
import java.util.stream.Collectors;

import de.lisaplus.lisa.${extraParam.serviceBase}.model.*;
import de.schlothauer.services.exceptions.*;

${script.printHello('test')}

/**
 * This class contains the Unit test for masking of class $targetType. 
 */
public class ${targetType}Handling {

    /**
     * For restoring of array properties with entryId attributes these entryId values need to match.
     * This method assumes that array dimension of objects <i>source</i> and <i>target</i> match!
     * @param source The object, which defines the entryId values
     * @param target The object, which is to inherit the entryId values.
     */
    public static void ensureMatchingEntryId(final ${targetType} source, final ${targetType} target) {
<%      allLines.clear()
        prepareStacks.call()
        createEnsureMatchingForType.call(currentType, allLines, 0)
        allLines.each { line -> %>${line}
<% } %>    }

    /**
     * Returns the value(s) associated with a mask key.
     * @param pojo The object to process
     * @param maskKey The mask key to process.
     * @return The value(s) associated with a mask key.
     */
    public static Object getValue(final ${targetType} pojo, final String maskKey) {
        switch(maskKey) {
<%      allLines.clear()
        prepareStacks.call()
        createGetValueForType.call(tunedType, allLines)
        allLines.each { line -> %>${line}
<% } %>
        default:
            throw new RuntimeException(String.format("Unsupported mask key '%s'!", maskKey));
        }
    }
<%     /* 1st loop: method checkXXXExists() */
        prepareStacks.call()
        printCheckExistsForType.call(tunedType)

        /* 2nd loop: methods ensureXXXExists() */
        prepareStacks.call()
        printEnsureExistsForType.call(tunedType)

        /* 3rd loop: method getXXX() for lists */
        prepareStacks.call()
        printGetForType.call(tunedType)

        /* 4th loop: method getXXXThrows() for lists */
        prepareStacks.call()
        printGetThrowsForType.call(tunedType)

        /* 5th loop: methods getXXXThrows() for single objects */
        prepareStacks.call()
        printGetSingleThrowsForType.call(tunedType)

        /* 6th loop: methods setXXX() */
        prepareStacks.call()
        printSetSingleForType.call(tunedType)

        for (String key : deepNestedListKeys) {
%>${printAddForKeyThrows.call(key)}
${printGetForKeyThrows.call(key)}
${printReplaceForKeyThrows.call(key)}
${printRemoveForKeyThrows.call(key)}<%
        }

        for (Map.Entry entry : deepNestedList2SingleChildKeys.entrySet()) {
            // Paraneter: keyArray, keyChild
%>${printSetForKeyThrows.call(entry.key, entry.value)}<%
        }

        if (verbose) println '// start add'
        for (String key : otherHandlingKeys) {
%>
${printAddOtherHandlingForKey.call(key)}<%
        }

        if (verbose) println '// start get'
        for (String key : otherHandlingKeys) {
%>
${printGetByIdOtherHandlingForKey.call(key)}<%
        }

        if (verbose) println '// start array get'
        for (String key : otherHandlingKeysForArray) {
%>
${printGetThrowsOtherHandlingForKey.call(key)}<%
        }

        if (verbose) println '// start replace'
        for (String key : otherHandlingKeys) {
%>
${printReplaceByIdOtherHandlingForKey.call(key)}<%
        }

        if (verbose) println '// start remove'
        for (String key : otherHandlingKeys) {
%>
${printRemoveByIdOtherHandlingForKey.call(key)}<%
        }
%>
}
